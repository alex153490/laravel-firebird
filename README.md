# laravel-firebird

To use this package:

Installation
------------

Install the Firebird PDO driver for PHP.

Mariuz's Blog has a very good step by step on this:
http://mapopa.blogspot.com/2009/04/php5-and-firebird-pdo-on-ubuntu-hardy.html

Install using composer:
```json
composer require sim1984/laravel-firebird
```

Update the `app/config/app.php`, add the service provider:
```json
'Firebird\FirebirdServiceProvider'.
```

For Laravel 5.1:
```php
Firebird\FirebirdServiceProvider::class,
```

You can remove the original DatabaseServiceProvider, as the original connection factory has also been extended.

Declare your connection in the database config, using 'firebird' as the
connecion type.
Other keys that are needed:
```php
'firebird' => [
    'driver'   => 'firebird',
    'host'     => env('DB_HOST', 'localhost'),
    'database' => env('DB_DATABASE','/storage/firebird/APPLICATION.FDB'),
    'username' => env('DB_USERNAME', 'sysdba'),
    'password' => env('DB_PASSWORD', 'masterkey'),
    'charset'  => env('DB_CHARSET', 'UTF8'),
    'role'     => 'RDB$ADMIN',
    'engine_version' => '3.0.1',
],
```

And add to your .env
```
DB_CHARSET=UTF8
```

If necessary, change the UTF8 to any other charset

This package is a branch jacquestvanzuydam/laravel-firebird package and 
extends its functionality. Tested on Laravel-5.2.

Added the following features:

* Added support for direct control sequences in 

```php
        // CREATE SEQUENCE "seq_users_id"
        Schema::createSequence('seq_users_id');

        // ALTER SEQUENCE "seq_users_id" RESTART WITH 10 INCREMENT BY 5
        Schema::sequence('seq_users_id', function (SequenceBlueprint $sequence) {
            $sequence->increment(5);
            $sequence->restart(10);
        });

        // DROP SEQUENCE "seq_users_id"
        Schema::dropSequence('seq_users_id');
```

* The implementation of auto-increment columns in two ways: 
- through the automatic generation of sequences and before insert trigger

```php
        // CREATE TABLE "users" (
        //   "id"              INTEGER NOT NULL PRIMARY KEY,
        //   "name"            VARCHAR(255) NOT NULL,
        //   "email"           VARCHAR(255) NOT NULL,
        //   "password"        VARCHAR(255) NOT NULL,
        //   "remember_token"  VARCHAR(100),
        //   "created_at"      TIMESTAMP,
        //   "updated_at"      TIMESTAMP
        // );
        // ALTER TABLE "users" ADD PRIMARY KEY ("id");
        // ALTER TABLE "users" ADD CONSTRAINT "users_email_unique" UNIQUE ("email");
        // CREATE SEQUENCE "seq_users";
        // CREATE OR ALTER TRIGGER "tr_users_bi" FOR "users"
        // ACTIVE BEFORE INSERT
        // AS
        // BEGIN
        //   IF (NEW."id" IS NULL) THEN
        //     NEW."id" = NEXT VALUE FOR "seq_users";
        // END
        Schema::create('users', function (Blueprint $table) {
            $table->increments('id');
            $table->string('name');
            $table->string('email')->unique();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });

        // DROP TABLE "users";
        // DROP SEQUENCE "seq_users";
        Schema::drop('users');
```

- using identity fields (only in Firebird 3.0).

```php
        // CREATE TABLE "users" (
        //   "id"              INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        //   "name"            VARCHAR(255) NOT NULL,
        //   "email"           VARCHAR(255) NOT NULL,
        //   "password"        VARCHAR(255) NOT NULL,
        //   "remember_token"  VARCHAR(100),
        //   "created_at"      TIMESTAMP,
        //   "updated_at"      TIMESTAMP
        // );
        // ALTER TABLE "users" ADD CONSTRAINT "users_email_unique" UNIQUE ("email");
        Schema::create('users', function (Blueprint $table) {
            $table->useIdentity(); // only Firebird 3.0
            $table->increments('id');
            $table->string('name');
            $table->string('email')->unique();
            $table->string('password');
            $table->rememberToken();
            $table->timestamps();
        });  
```     
   
* The implementation of InsertGetId method is similar to the postgres, ie 
using RETURNING proposal.

* Create your own base model class in which insertAndSetId method is 
implemented through the prior receipt by the sequence identifier.

* Added additional methods for the execution of stored procedures and stored functions.

* Added Providing the connection parameters: the name of the role and Firebird 
version (to use the correct grammar).

PHP < 7.0.15 or < 7.1.1 has an error processing the RETURNING clause with Firebird 3.0
(see bug https://bugs.php.net/bug.php?id=72931).
You can use the following workaround for earlier versions in file /Firebird/Query/Grammars/FirebirdGrammar30.php.

```php

// ...............................

    /**
     * Fix PDO driver bug for 'INSERT ... RETURNING'
     * See https://bugs.php.net/bug.php?id=72931
     * Reproduced in Firebird 3.0 only
     * Remove when the bug is fixed!
     * 
     * @param \Illuminate\Database\Query\Builder $query
     * @param array $values
     * @param string $sequence
     * @param string $sql
     */
    private function fixInsertReturningBug(Builder $query, $values, $sequence, $sql)
    {
        /*
         * Since the PDO Firebird driver bug because of which is not executed 
         * sql query 'INSERT ... RETURNING', then we wrap the statement in 
         * the block and execute it. PDO may not recognize the colon (:) within 
         * a block properly, so we will not use it. The only way I found 
         * buyout perform a query via EXECUTE STATEMENT.
         */
        if (!is_array(reset($values))) {
            $values = [$values];
        }
        $table = $this->wrapTable($query->from);
        $columns = array_map([$this, 'wrap'], array_keys(reset($values)));
        $columnsWithTypeOf = [];
        foreach ($columns as $column) {
            $columnsWithTypeOf[] = "  {$column} TYPE OF COLUMN {$table}.{$column} = ?";
        }
        $ret_column = $this->wrap($sequence);

        $columns_str = $this->columnize(array_keys(reset($values)));

        $new_sql = "EXECUTE BLOCK (\n";
        $new_sql .= implode(",\n", $columnsWithTypeOf);
        $new_sql .= ")\n";
        $new_sql .= "RETURNS ({$ret_column} TYPE OF COLUMN {$table}.{$ret_column})\n";
        $new_sql .= "AS\n";
        $new_sql .= "  DECLARE STMT VARCHAR(8191);\n";
        $new_sql .= "BEGIN\n";
        $new_sql .= "  STMT = '{$sql}';\n";
        $new_sql .= "  EXECUTE STATEMENT (STMT) ({$columns_str})\n";

        if (!$query->getConnection()->getPdo()->inTransaction()) {
            // For some unknown reason, there is a ROLLBACK. Probably due to the COMMIT RETAINING.
            $new_sql .= "  WITH AUTONOMOUS TRANSACTION\n";
        }
        $new_sql .= "  INTO {$ret_column};\n";
        $new_sql .= "  SUSPEND;\n";
        $new_sql .= "END";

        return $new_sql;
    }

    /**
     * Compile an insert and get ID statement into SQL.
     *
     * @param  \Illuminate\Database\Query\Builder  $query
     * @param  array   $values
     * @param  string  $sequence
     * @return string
     */
    public function compileInsertGetId(Builder $query, $values, $sequence)
    {
        $sql = parent::compileInsertGetId($query, $values, $sequence);
        // Fix PDO driver bug for 'INSERT ... RETURNING'
        // See https://bugs.php.net/bug.php?id=72931
        $sql = $this->fixInsertReturningBug($query, $values, $sequence, $sql);

        return $sql;
    }
	
// .............................	

``` 